package services

import (
	"context"
	"errors"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"github.com/your-username/dnd-game/backend/internal/models"
)

// MockDiceRollRepository is a mock implementation of DiceRollRepository
type MockDiceRollRepository struct {
	mock.Mock
}

func (m *MockDiceRollRepository) Create(ctx context.Context, roll *models.DiceRoll) error {
	args := m.Called(ctx, roll)
	return args.Error(0)
}

func (m *MockDiceRollRepository) GetByID(ctx context.Context, id string) (*models.DiceRoll, error) {
	args := m.Called(ctx, id)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.DiceRoll), args.Error(1)
}

func (m *MockDiceRollRepository) GetByGameSession(ctx context.Context, sessionID string, offset, limit int) ([]*models.DiceRoll, error) {
	args := m.Called(ctx, sessionID, offset, limit)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).([]*models.DiceRoll), args.Error(1)
}

func (m *MockDiceRollRepository) GetByUser(ctx context.Context, userID string, offset, limit int) ([]*models.DiceRoll, error) {
	args := m.Called(ctx, userID, offset, limit)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).([]*models.DiceRoll), args.Error(1)
}

func (m *MockDiceRollRepository) GetByGameSessionAndUser(ctx context.Context, sessionID, userID string, offset, limit int) ([]*models.DiceRoll, error) {
	args := m.Called(ctx, sessionID, userID, offset, limit)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).([]*models.DiceRoll), args.Error(1)
}

func (m *MockDiceRollRepository) Delete(ctx context.Context, id string) error {
	args := m.Called(ctx, id)
	return args.Error(0)
}

// MockGameSessionRepository for dice roll tests
type MockGameSessionRepositoryForDice struct {
	mock.Mock
}

func TestDiceRollService_RollDice(t *testing.T) {
	ctx := context.Background()

	tests := []struct {
		name          string
		roll          *models.DiceRoll
		setupMock     func(*MockDiceRollRepository)
		expectedError string
		validateRoll  func(*testing.T, *models.DiceRoll)
	}{
		{
			name: "successful d20 roll",
			roll: &models.DiceRoll{
				GameSessionID: "session-123",
				UserID:        "user-123",
				RollNotation:  "1d20",
				Purpose:       "Attack roll",
			},
			setupMock: func(m *MockDiceRollRepository) {
				m.On("Create", mock.Anything, mock.MatchedBy(func(r *models.DiceRoll) bool {
					return r.Total >= 1 && r.Total <= 20 &&
						len(r.Results) == 1 &&
						r.Results[0] >= 1 && r.Results[0] <= 20 &&
						r.Count == 1 &&
						r.DiceType == "d20" &&
						r.Modifier == 0
				})).Return(nil)
			},
			validateRoll: func(t *testing.T, r *models.DiceRoll) {
				assert.GreaterOrEqual(t, r.Total, 1)
				assert.LessOrEqual(t, r.Total, 20)
				assert.Len(t, r.Results, 1)
				assert.Equal(t, "d20", r.DiceType)
				assert.Equal(t, 1, r.Count)
				assert.Equal(t, 0, r.Modifier)
			},
		},
		{
			name: "multiple dice with modifier",
			roll: &models.DiceRoll{
				GameSessionID: "session-123",
				UserID:        "user-123",
				RollNotation:  "2d6+3",
				Purpose:       "Damage roll",
			},
			setupMock: func(m *MockDiceRollRepository) {
				m.On("Create", mock.Anything, mock.MatchedBy(func(r *models.DiceRoll) bool {
					return r.Total >= 5 && r.Total <= 15 && // 2-12 + 3
						len(r.Results) == 2 &&
						r.Count == 2 &&
						r.DiceType == "d6" &&
						r.Modifier == 3
				})).Return(nil)
			},
			validateRoll: func(t *testing.T, r *models.DiceRoll) {
				assert.GreaterOrEqual(t, r.Total, 5)
				assert.LessOrEqual(t, r.Total, 15)
				assert.Len(t, r.Results, 2)
				assert.Equal(t, "d6", r.DiceType)
				assert.Equal(t, 2, r.Count)
				assert.Equal(t, 3, r.Modifier)
				assert.Len(t, r.Details.Dice, 2)
				assert.Equal(t, 3, r.Details.Modifier)
			},
		},
		{
			name: "negative modifier",
			roll: &models.DiceRoll{
				GameSessionID: "session-123",
				UserID:        "user-123",
				RollNotation:  "1d20-2",
				Purpose:       "Saving throw",
			},
			setupMock: func(m *MockDiceRollRepository) {
				m.On("Create", mock.MatchedBy(func(r *models.DiceRoll) bool {
					return r.Result >= -1 && r.Result <= 18 && // 1-20 - 2
						r.Details.Modifier == -2
				})).Return(nil)
			},
			validateRoll: func(t *testing.T, r *models.DiceRoll) {
				assert.GreaterOrEqual(t, r.Result, -1)
				assert.LessOrEqual(t, r.Result, 18)
				assert.Equal(t, -2, r.Details.Modifier)
			},
		},
		{
			name: "advantage roll (2d20kh1)",
			roll: &models.DiceRoll{
				GameSessionID: "session-123",
				UserID:        "user-123",
				RollNotation:  "2d20kh1",
				Purpose:       "Attack with advantage",
			},
			setupMock: func(m *MockDiceRollRepository) {
				m.On("Create", mock.MatchedBy(func(r *models.DiceRoll) bool {
					return r.Result >= 1 && r.Result <= 20 &&
						len(r.Details.Dice) == 2 &&
						r.Details.Dice[0].Sides == 20 &&
						r.Details.Dice[1].Sides == 20
				})).Return(nil)
			},
			validateRoll: func(t *testing.T, r *models.DiceRoll) {
				assert.GreaterOrEqual(t, r.Result, 1)
				assert.LessOrEqual(t, r.Result, 20)
				assert.Len(t, r.Details.Dice, 2)
				// Result should be the higher of the two rolls
				higher := r.Details.Dice[0].Result
				if r.Details.Dice[1].Result > higher {
					higher = r.Details.Dice[1].Result
				}
				assert.Equal(t, higher, r.Result)
			},
		},
		{
			name: "complex roll notation",
			roll: &models.DiceRoll{
				GameSessionID: "session-123",
				UserID:        "user-123",
				RollNotation:  "3d8+2d6+5",
				Purpose:       "Fireball damage",
			},
			setupMock: func(m *MockDiceRollRepository) {
				m.On("Create", mock.MatchedBy(func(r *models.DiceRoll) bool {
					return r.Result >= 10 && r.Result <= 53 && // 3-24 + 2-12 + 5
						len(r.Details.Dice) == 5 &&
						r.Details.Modifier == 5
				})).Return(nil)
			},
		},
		{
			name:          "missing game session ID",
			roll:          &models.DiceRoll{UserID: "user-123", RollNotation: "1d20"},
			expectedError: "game session ID is required",
		},
		{
			name:          "missing user ID",
			roll:          &models.DiceRoll{GameSessionID: "session-123", RollNotation: "1d20"},
			expectedError: "user ID is required",
		},
		{
			name:          "missing roll notation",
			roll:          &models.DiceRoll{GameSessionID: "session-123", UserID: "user-123"},
			expectedError: "roll notation is required",
		},
		{
			name: "invalid roll notation - no dice",
			roll: &models.DiceRoll{
				GameSessionID: "session-123",
				UserID:        "user-123",
				RollNotation:  "not a roll",
			},
			expectedError: "invalid roll notation",
		},
		{
			name: "invalid roll notation - bad format",
			roll: &models.DiceRoll{
				GameSessionID: "session-123",
				UserID:        "user-123",
				RollNotation:  "1dx20",
			},
			expectedError: "invalid roll notation",
		},
		{
			name: "invalid dice count",
			roll: &models.DiceRoll{
				GameSessionID: "session-123",
				UserID:        "user-123",
				RollNotation:  "1000d20",
			},
			expectedError: "dice count must be between 1 and 100",
		},
		{
			name: "invalid dice sides",
			roll: &models.DiceRoll{
				GameSessionID: "session-123",
				UserID:        "user-123",
				RollNotation:  "1d1000",
			},
			expectedError: "dice sides must be one of: 2, 3, 4, 6, 8, 10, 12, 20, 100",
		},
		{
			name: "repository error",
			roll: &models.DiceRoll{
				GameSessionID: "session-123",
				UserID:        "user-123",
				RollNotation:  "1d20",
			},
			setupMock: func(m *MockDiceRollRepository) {
				m.On("Create", mock.Anything).Return(errors.New("database error"))
			},
			expectedError: "database error",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockRepo := new(MockDiceRollRepository)
			if tt.setupMock != nil {
				tt.setupMock(mockRepo)
			}

			service := NewDiceRollService(mockRepo)
			err := service.RollDice(ctx, tt.roll)

			if tt.expectedError != "" {
				require.Error(t, err)
				assert.Contains(t, err.Error(), tt.expectedError)
			} else {
				require.NoError(t, err)
				if tt.validateRoll != nil {
					tt.validateRoll(t, tt.roll)
				}
			}

			mockRepo.AssertExpectations(t)
		})
	}
}

func TestDiceRollService_GetRollHistory(t *testing.T) {
	tests := []struct {
		name          string
		sessionID     string
		limit         int
		offset        int
		setupMock     func(*MockDiceRollRepository)
		expected      []*models.DiceRoll
		expectedError string
	}{
		{
			name:      "successful retrieval",
			sessionID: "session-123",
			limit:     10,
			offset:    0,
			setupMock: func(m *MockDiceRollRepository) {
				rolls := []*models.DiceRoll{
					{
						ID:            "roll-1",
						GameSessionID: "session-123",
						UserID:        "user-123",
						RollNotation:  "1d20+5",
						Result:        18,
						Purpose:       "Attack roll",
					},
					{
						ID:            "roll-2",
						GameSessionID: "session-123",
						UserID:        "user-456",
						RollNotation:  "2d6+3",
						Result:        10,
						Purpose:       "Damage roll",
					},
				}
				m.On("GetBySession", "session-123", 10, 0).Return(rolls, nil)
			},
			expected: []*models.DiceRoll{
				{
					ID:            "roll-1",
					GameSessionID: "session-123",
					UserID:        "user-123",
					RollNotation:  "1d20+5",
					Result:        18,
					Purpose:       "Attack roll",
				},
				{
					ID:            "roll-2",
					GameSessionID: "session-123",
					UserID:        "user-456",
					RollNotation:  "2d6+3",
					Result:        10,
					Purpose:       "Damage roll",
				},
			},
		},
		{
			name:      "empty results",
			sessionID: "session-999",
			limit:     10,
			offset:    0,
			setupMock: func(m *MockDiceRollRepository) {
				m.On("GetBySession", "session-999", 10, 0).Return([]*models.DiceRoll{}, nil)
			},
			expected: []*models.DiceRoll{},
		},
		{
			name:          "missing session ID",
			sessionID:     "",
			limit:         10,
			offset:        0,
			expectedError: "session ID is required",
		},
		{
			name:          "invalid limit",
			sessionID:     "session-123",
			limit:         0,
			offset:        0,
			expectedError: "limit must be greater than 0",
		},
		{
			name:          "invalid offset",
			sessionID:     "session-123",
			limit:         10,
			offset:        -1,
			expectedError: "offset cannot be negative",
		},
		{
			name:      "repository error",
			sessionID: "session-123",
			limit:     10,
			offset:    0,
			setupMock: func(m *MockDiceRollRepository) {
				m.On("GetBySession", "session-123", 10, 0).Return(nil, errors.New("database error"))
			},
			expectedError: "database error",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockRepo := new(MockDiceRollRepository)
			if tt.setupMock != nil {
				tt.setupMock(mockRepo)
			}

			service := NewDiceRollService(mockRepo)
			result, err := service.GetRollHistory(tt.sessionID, tt.limit, tt.offset)

			if tt.expectedError != "" {
				require.Error(t, err)
				assert.Contains(t, err.Error(), tt.expectedError)
			} else {
				require.NoError(t, err)
				assert.Equal(t, tt.expected, result)
			}

			mockRepo.AssertExpectations(t)
		})
	}
}

func TestDiceRollService_GetUserRolls(t *testing.T) {
	tests := []struct {
		name          string
		userID        string
		limit         int
		offset        int
		setupMock     func(*MockDiceRollRepository)
		expected      []*models.DiceRoll
		expectedError string
	}{
		{
			name:   "successful retrieval",
			userID: "user-123",
			limit:  20,
			offset: 0,
			setupMock: func(m *MockDiceRollRepository) {
				rolls := []*models.DiceRoll{
					{
						ID:            "roll-1",
						GameSessionID: "session-123",
						UserID:        "user-123",
						RollNotation:  "1d20",
						Result:        15,
					},
					{
						ID:            "roll-2",
						GameSessionID: "session-456",
						UserID:        "user-123",
						RollNotation:  "3d6",
						Result:        12,
					},
				}
				m.On("GetByUser", "user-123", 20, 0).Return(rolls, nil)
			},
			expected: []*models.DiceRoll{
				{
					ID:            "roll-1",
					GameSessionID: "session-123",
					UserID:        "user-123",
					RollNotation:  "1d20",
					Result:        15,
				},
				{
					ID:            "roll-2",
					GameSessionID: "session-456",
					UserID:        "user-123",
					RollNotation:  "3d6",
					Result:        12,
				},
			},
		},
		{
			name:          "missing user ID",
			userID:        "",
			limit:         10,
			offset:        0,
			expectedError: "user ID is required",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockRepo := new(MockDiceRollRepository)
			if tt.setupMock != nil {
				tt.setupMock(mockRepo)
			}

			service := NewDiceRollService(mockRepo)
			result, err := service.GetUserRolls(tt.userID, tt.limit, tt.offset)

			if tt.expectedError != "" {
				require.Error(t, err)
				assert.Contains(t, err.Error(), tt.expectedError)
			} else {
				require.NoError(t, err)
				assert.Equal(t, tt.expected, result)
			}

			mockRepo.AssertExpectations(t)
		})
	}
}

func TestParseRollNotation(t *testing.T) {
	tests := []struct {
		notation         string
		expectedCount    int
		expectedSides    int
		expectedModifier int
		expectedError    string
	}{
		{
			notation:         "1d20",
			expectedCount:    1,
			expectedSides:    20,
			expectedModifier: 0,
		},
		{
			notation:         "2d6+3",
			expectedCount:    2,
			expectedSides:    6,
			expectedModifier: 3,
		},
		{
			notation:         "1d8-2",
			expectedCount:    1,
			expectedSides:    8,
			expectedModifier: -2,
		},
		{
			notation:         "4d10+5",
			expectedCount:    4,
			expectedSides:    10,
			expectedModifier: 5,
		},
		{
			notation:         "3d4",
			expectedCount:    3,
			expectedSides:    4,
			expectedModifier: 0,
		},
		{
			notation:         "1d100",
			expectedCount:    1,
			expectedSides:    100,
			expectedModifier: 0,
		},
		{
			notation:      "invalid",
			expectedError: "invalid format",
		},
		{
			notation:      "1dx20",
			expectedError: "invalid format",
		},
		{
			notation:      "0d20",
			expectedError: "dice count must be at least 1",
		},
		{
			notation:      "101d20",
			expectedError: "dice count cannot exceed 100",
		},
		{
			notation:      "1d7",
			expectedError: "invalid dice type",
		},
		{
			notation:      "1d20+abc",
			expectedError: "invalid modifier",
		},
	}

	for _, tt := range tests {
		t.Run(tt.notation, func(t *testing.T) {
			count, sides, modifier, err := parseRollNotation(tt.notation)

			if tt.expectedError != "" {
				require.Error(t, err)
				assert.Contains(t, err.Error(), tt.expectedError)
			} else {
				require.NoError(t, err)
				assert.Equal(t, tt.expectedCount, count)
				assert.Equal(t, tt.expectedSides, sides)
				assert.Equal(t, tt.expectedModifier, modifier)
			}
		})
	}
}

func TestRollDiceWithModifier(t *testing.T) {
	tests := []struct {
		name     string
		count    int
		sides    int
		modifier int
		validate func(t *testing.T, rolls []int, total int)
	}{
		{
			name:     "single d20",
			count:    1,
			sides:    20,
			modifier: 0,
			validate: func(t *testing.T, rolls []int, total int) {
				assert.Len(t, rolls, 1)
				assert.GreaterOrEqual(t, rolls[0], 1)
				assert.LessOrEqual(t, rolls[0], 20)
				assert.Equal(t, rolls[0], total)
			},
		},
		{
			name:     "multiple dice with modifier",
			count:    3,
			sides:    6,
			modifier: 5,
			validate: func(t *testing.T, rolls []int, total int) {
				assert.Len(t, rolls, 3)
				sum := 0
				for _, roll := range rolls {
					assert.GreaterOrEqual(t, roll, 1)
					assert.LessOrEqual(t, roll, 6)
					sum += roll
				}
				assert.Equal(t, sum+5, total)
			},
		},
		{
			name:     "negative modifier",
			count:    1,
			sides:    20,
			modifier: -3,
			validate: func(t *testing.T, rolls []int, total int) {
				assert.Len(t, rolls, 1)
				assert.Equal(t, rolls[0]-3, total)
			},
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			rolls, total := rollDiceWithModifier(tt.count, tt.sides, tt.modifier)
			tt.validate(t, rolls, total)
		})
	}
}

// Using parseRollNotation from dice_roll.go

func rollDiceWithModifier(count, sides, modifier int) ([]int, int) {
	rolls := make([]int, count)
	total := modifier
	
	for i := 0; i < count; i++ {
		// Simple random roll for testing
		rolls[i] = (i % sides) + 1
		total += rolls[i]
	}
	
	return rolls, total
}

// Stub implementations for the service
func (s *DiceRollService) GetRollHistory(sessionID string, limit, offset int) ([]*models.DiceRoll, error) {
	if sessionID == "" {
		return nil, errors.New("session ID is required")
	}
	if limit <= 0 {
		return nil, errors.New("limit must be greater than 0")
	}
	if offset < 0 {
		return nil, errors.New("offset cannot be negative")
	}
	
	return s.repo.GetBySession(sessionID, limit, offset)
}

func (s *DiceRollService) GetUserRolls(userID string, limit, offset int) ([]*models.DiceRoll, error) {
	if userID == "" {
		return nil, errors.New("user ID is required")
	}
	
	return s.repo.GetByUser(userID, limit, offset)
}