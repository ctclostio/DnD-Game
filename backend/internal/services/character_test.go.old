package services

import (
	"context"
	"errors"
	"testing"
	"time"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/stretchr/testify/require"
	"github.com/your-username/dnd-game/backend/internal/models"
)

// MockCharacterRepository is a mock implementation of CharacterRepository
type MockCharacterRepository struct {
	mock.Mock
}

func (m *MockCharacterRepository) Create(ctx context.Context, character *models.Character) error {
	args := m.Called(ctx, character)
	return args.Error(0)
}

func (m *MockCharacterRepository) GetByID(ctx context.Context, id string) (*models.Character, error) {
	args := m.Called(ctx, id)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.Character), args.Error(1)
}

func (m *MockCharacterRepository) GetByUserID(ctx context.Context, userID string) ([]*models.Character, error) {
	args := m.Called(ctx, userID)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).([]*models.Character), args.Error(1)
}

func (m *MockCharacterRepository) Update(ctx context.Context, character *models.Character) error {
	args := m.Called(ctx, character)
	return args.Error(0)
}

func (m *MockCharacterRepository) Delete(ctx context.Context, id string) error {
	args := m.Called(ctx, id)
	return args.Error(0)
}

func (m *MockCharacterRepository) List(ctx context.Context, offset, limit int) ([]*models.Character, error) {
	args := m.Called(ctx, offset, limit)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).([]*models.Character), args.Error(1)
}

// MockCustomClassRepository is a mock implementation of CustomClassRepository
type MockCustomClassRepository struct {
	mock.Mock
}

// Use the MockLLMProvider from the llm_providers.go file instead

func TestCharacterService_CreateCharacter(t *testing.T) {
	ctx := context.Background()

	tests := []struct {
		name          string
		character     *models.Character
		setupMock     func(*MockCharacterRepository)
		expectedError string
		validate      func(*testing.T, *models.Character)
	}{
		{
			name: "successful creation with calculated fields",
			character: &models.Character{
				UserID: "user-123",
				Name:   "Thorin Oakenshield",
				Race:   "Dwarf",
				Class:  "Fighter",
				Level:  1,
				Attributes: models.Attributes{
					Strength:     16,
					Dexterity:    12,
					Constitution: 14,
					Intelligence: 10,
					Wisdom:       13,
					Charisma:     8,
				},
			},
			setupMock: func(m *MockCharacterRepository) {
				m.On("Create", ctx, mock.MatchedBy(func(c *models.Character) bool {
					return c.HitPoints == 12 && // 10 + 2 (CON modifier)
						c.MaxHitPoints == 12 &&
						c.ArmorClass == 11 && // 10 + 1 (DEX modifier)
						c.Speed == 30 &&
						c.CarryCapacity == 240 && // 16 * 15
						c.AttunementSlotsMax == 3
				})).Return(nil)
			},
			validate: func(t *testing.T, c *models.Character) {
				assert.Equal(t, 12, c.HitPoints)
				assert.Equal(t, 12, c.MaxHitPoints)
				assert.Equal(t, 11, c.ArmorClass)
				assert.Equal(t, 30, c.Speed)
				assert.Equal(t, float64(240), c.CarryCapacity)
				assert.Equal(t, 3, c.AttunementSlotsMax)
			},
		},
		{
			name: "missing user ID",
			character: &models.Character{
				Name:  "Invalid",
				Race:  "Human",
				Class: "Fighter",
			},
			expectedError: "user ID is required",
		},
		{
			name: "missing name",
			character: &models.Character{
				UserID: "user-123",
				Race:   "Human",
				Class:  "Fighter",
			},
			expectedError: "character name is required",
		},
		{
			name: "missing race",
			character: &models.Character{
				UserID: "user-123",
				Name:   "Invalid",
				Class:  "Fighter",
			},
			expectedError: "character race is required",
		},
		{
			name: "missing class",
			character: &models.Character{
				UserID: "user-123",
				Name:   "Invalid",
				Race:   "Human",
			},
			expectedError: "character class is required",
		},
		{
			name: "repository error",
			character: &models.Character{
				UserID: "user-123",
				Name:   "Valid",
				Race:   "Human",
				Class:  "Fighter",
			},
			setupMock: func(m *MockCharacterRepository) {
				m.On("Create", ctx, mock.Anything).Return(errors.New("database error"))
			},
			expectedError: "database error",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockRepo := new(MockCharacterRepository)
			mockLLM := new(MockLLMProvider)
			
			if tt.setupMock != nil {
				tt.setupMock(mockRepo)
			}

			service := NewCharacterService(mockRepo, nil, mockLLM)
			err := service.CreateCharacter(ctx, tt.character)

			if tt.expectedError != "" {
				require.Error(t, err)
				assert.Contains(t, err.Error(), tt.expectedError)
			} else {
				require.NoError(t, err)
				if tt.validate != nil {
					tt.validate(t, tt.character)
				}
			}

			mockRepo.AssertExpectations(t)
		})
	}
}

func TestCharacterService_GetAllCharacters(t *testing.T) {
	ctx := context.Background()

	tests := []struct {
		name          string
		userID        string
		setupMock     func(*MockCharacterRepository)
		expected      []*models.Character
		expectedError string
	}{
		{
			name:   "get characters for user",
			userID: "user-123",
			setupMock: func(m *MockCharacterRepository) {
				chars := []*models.Character{
					{ID: "char-1", UserID: "user-123", Name: "Char1"},
					{ID: "char-2", UserID: "user-123", Name: "Char2"},
				}
				m.On("GetByUserID", ctx, "user-123").Return(chars, nil)
			},
			expected: []*models.Character{
				{ID: "char-1", UserID: "user-123", Name: "Char1"},
				{ID: "char-2", UserID: "user-123", Name: "Char2"},
			},
		},
		{
			name:     "empty user ID returns empty list",
			userID:   "",
			expected: []*models.Character{},
		},
		{
			name:   "repository error",
			userID: "user-123",
			setupMock: func(m *MockCharacterRepository) {
				m.On("GetByUserID", ctx, "user-123").Return(nil, errors.New("database error"))
			},
			expectedError: "database error",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockRepo := new(MockCharacterRepository)
			mockLLM := new(MockLLMProvider)
			
			if tt.setupMock != nil {
				tt.setupMock(mockRepo)
			}

			service := NewCharacterService(mockRepo, nil, mockLLM)
			result, err := service.GetAllCharacters(ctx, tt.userID)

			if tt.expectedError != "" {
				require.Error(t, err)
				assert.Contains(t, err.Error(), tt.expectedError)
			} else {
				require.NoError(t, err)
				assert.Equal(t, tt.expected, result)
			}

			mockRepo.AssertExpectations(t)
		})
	}
}

func TestCharacterService_GetCharacterByID(t *testing.T) {
	ctx := context.Background()

	tests := []struct {
		name          string
		characterID   string
		setupMock     func(*MockCharacterRepository)
		expected      *models.Character
		expectedError string
	}{
		{
			name:        "successful retrieval",
			characterID: "char-123",
			setupMock: func(m *MockCharacterRepository) {
				char := &models.Character{
					ID:     "char-123",
					UserID: "user-123",
					Name:   "Test Character",
				}
				m.On("GetByID", ctx, "char-123").Return(char, nil)
			},
			expected: &models.Character{
				ID:     "char-123",
				UserID: "user-123",
				Name:   "Test Character",
			},
		},
		{
			name:        "character not found",
			characterID: "char-999",
			setupMock: func(m *MockCharacterRepository) {
				m.On("GetByID", ctx, "char-999").Return(nil, errors.New("not found"))
			},
			expectedError: "not found",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockRepo := new(MockCharacterRepository)
			mockLLM := new(MockLLMProvider)
			
			if tt.setupMock != nil {
				tt.setupMock(mockRepo)
			}

			service := NewCharacterService(mockRepo, nil, mockLLM)
			result, err := service.GetCharacterByID(ctx, tt.characterID)

			if tt.expectedError != "" {
				require.Error(t, err)
				assert.Contains(t, err.Error(), tt.expectedError)
			} else {
				require.NoError(t, err)
				assert.Equal(t, tt.expected, result)
			}

			mockRepo.AssertExpectations(t)
		})
	}
}

func TestCharacterService_UpdateCharacter(t *testing.T) {
	ctx := context.Background()

	tests := []struct {
		name          string
		character     *models.Character
		setupMock     func(*MockCharacterRepository)
		expectedError string
	}{
		{
			name: "successful update",
			character: &models.Character{
				ID:    "char-123",
				Name:  "Updated Name",
				Level: 2,
			},
			setupMock: func(m *MockCharacterRepository) {
				existing := &models.Character{
					ID:        "char-123",
					UserID:    "user-123",
					Name:      "Old Name",
					CreatedAt: timeNow(),
				}
				m.On("GetByID", ctx, "char-123").Return(existing, nil)
				m.On("Update", ctx, mock.MatchedBy(func(c *models.Character) bool {
					return c.ID == "char-123" &&
						c.UserID == "user-123" && // Preserved from existing
						c.Name == "Updated Name" &&
						c.CreatedAt.Equal(existing.CreatedAt) // Preserved
				})).Return(nil)
			},
		},
		{
			name:          "missing character ID",
			character:     &models.Character{Name: "No ID"},
			expectedError: "character ID is required",
		},
		{
			name: "character not found",
			character: &models.Character{
				ID: "char-999",
			},
			setupMock: func(m *MockCharacterRepository) {
				m.On("GetByID", ctx, "char-999").Return(nil, errors.New("not found"))
			},
			expectedError: "character not found",
		},
		{
			name: "repository update error",
			character: &models.Character{
				ID:   "char-123",
				Name: "Updated",
			},
			setupMock: func(m *MockCharacterRepository) {
				existing := &models.Character{
					ID:     "char-123",
					UserID: "user-123",
				}
				m.On("GetByID", ctx, "char-123").Return(existing, nil)
				m.On("Update", ctx, mock.Anything).Return(errors.New("update failed"))
			},
			expectedError: "update failed",
		},
	}

	for _, tt := range tests {
		t.Run(tt.name, func(t *testing.T) {
			mockRepo := new(MockCharacterRepository)
			mockLLM := new(MockLLMProvider)
			
			if tt.setupMock != nil {
				tt.setupMock(mockRepo)
			}

			service := NewCharacterService(mockRepo, nil, mockLLM)
			err := service.UpdateCharacter(ctx, tt.character)

			if tt.expectedError != "" {
				require.Error(t, err)
				assert.Contains(t, err.Error(), tt.expectedError)
			} else {
				require.NoError(t, err)
			}

			mockRepo.AssertExpectations(t)
		})
	}
}

func TestCharacterService_CalculateHitPoints(t *testing.T) {
	service := &CharacterService{}

	tests := []struct {
		class        string
		level        int
		constitution int
		expected     int
	}{
		{"fighter", 1, 14, 12},    // 10 + 2 (CON mod)
		{"wizard", 1, 10, 6},       // 6 + 0 (CON mod)
		{"barbarian", 1, 16, 15},  // 12 + 3 (CON mod)
		{"fighter", 5, 14, 40},    // 10 + 4*6 + 5*2 (average roll + CON mod)
		{"wizard", 3, 12, 15},     // 6 + 2*4 + 3*1 (average roll + CON mod)
		{"unknown", 1, 14, 10},    // Default: 8 + 2 (CON mod)
	}

	for _, tt := range tests {
		t.Run(tt.class+"_level"+string(rune('0'+tt.level)), func(t *testing.T) {
			hp := service.CalculateHitPoints(tt.class, tt.level, tt.constitution)
			assert.Equal(t, tt.expected, hp)
		})
	}
}

func TestGetModifier(t *testing.T) {
	tests := []struct {
		ability  int
		expected int
	}{
		{1, -5},
		{2, -4},
		{3, -4},
		{4, -3},
		{5, -3},
		{6, -2},
		{7, -2},
		{8, -1},
		{9, -1},
		{10, 0},
		{11, 0},
		{12, 1},
		{13, 1},
		{14, 2},
		{15, 2},
		{16, 3},
		{17, 3},
		{18, 4},
		{19, 4},
		{20, 5},
		{30, 10},
	}

	for _, tt := range tests {
		t.Run(string(rune('0'+tt.ability)), func(t *testing.T) {
			mod := getModifier(tt.ability)
			assert.Equal(t, tt.expected, mod)
		})
	}
}

func TestCalculateCarryCapacity(t *testing.T) {
	tests := []struct {
		strength int
		expected float64
	}{
		{10, 150},
		{15, 225},
		{20, 300},
		{8, 120},
	}

	for _, tt := range tests {
		t.Run(string(rune('0'+tt.strength)), func(t *testing.T) {
			capacity := CalculateCarryCapacity(tt.strength)
			assert.Equal(t, tt.expected, capacity)
		})
	}
}

// Helper functions
func timeNow() time.Time {
	return time.Now().Truncate(time.Second)
}