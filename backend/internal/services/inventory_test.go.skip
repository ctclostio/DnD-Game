package services

import (
	"errors"
	"testing"

	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/mock"
	"github.com/your-username/dnd-game/backend/internal/models"
)

// Mock inventory repository
type MockInventoryRepository struct {
	mock.Mock
}

func (m *MockInventoryRepository) CreateItem(item *models.Item) error {
	args := m.Called(item)
	return args.Error(0)
}

func (m *MockInventoryRepository) GetItem(itemID string) (*models.Item, error) {
	args := m.Called(itemID)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.Item), args.Error(1)
}

func (m *MockInventoryRepository) GetItemsByType(itemType models.ItemType) ([]*models.Item, error) {
	args := m.Called(itemType)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).([]*models.Item), args.Error(1)
}

func (m *MockInventoryRepository) AddItemToInventory(characterID, itemID string, quantity int) error {
	args := m.Called(characterID, itemID, quantity)
	return args.Error(0)
}

func (m *MockInventoryRepository) RemoveItemFromInventory(characterID, itemID string, quantity int) error {
	args := m.Called(characterID, itemID, quantity)
	return args.Error(0)
}

func (m *MockInventoryRepository) GetCharacterInventory(characterID string) ([]*models.InventoryItem, error) {
	args := m.Called(characterID)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).([]*models.InventoryItem), args.Error(1)
}

func (m *MockInventoryRepository) EquipItem(characterID, itemID string, equip bool) error {
	args := m.Called(characterID, itemID, equip)
	return args.Error(0)
}

func (m *MockInventoryRepository) AttuneItem(characterID, itemID string) error {
	args := m.Called(characterID, itemID)
	return args.Error(0)
}

func (m *MockInventoryRepository) UnattuneItem(characterID, itemID string) error {
	args := m.Called(characterID, itemID)
	return args.Error(0)
}

func (m *MockInventoryRepository) GetCharacterCurrency(characterID string) (*models.Currency, error) {
	args := m.Called(characterID)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.Currency), args.Error(1)
}

func (m *MockInventoryRepository) UpdateCharacterCurrency(currency *models.Currency) error {
	args := m.Called(currency)
	return args.Error(0)
}

func (m *MockInventoryRepository) GetCharacterWeight(characterID string) (*models.InventoryWeight, error) {
	args := m.Called(characterID)
	if args.Get(0) == nil {
		return nil, args.Error(1)
	}
	return args.Get(0).(*models.InventoryWeight), args.Error(1)
}

func TestInventoryService_AddItemToCharacter(t *testing.T) {
	t.Run("successful addition", func(t *testing.T) {
		mockInvRepo := new(MockInventoryRepository)
		mockCharRepo := new(MockCharacterRepository)
		service := NewInventoryService(mockInvRepo, mockCharRepo)

		characterID := "char-123"
		itemID := "item-456"
		quantity := 2

		character := &models.Character{ID: characterID, Name: "Test Character"}
		item := &models.Item{ID: itemID, Name: "Longsword"}

		mockCharRepo.On("GetCharacterByID", characterID).Return(character, nil)
		mockInvRepo.On("GetItem", itemID).Return(item, nil)
		mockInvRepo.On("AddItemToInventory", characterID, itemID, quantity).Return(nil)

		err := service.AddItemToCharacter(characterID, itemID, quantity)
		assert.NoError(t, err)
		mockCharRepo.AssertExpectations(t)
		mockInvRepo.AssertExpectations(t)
	})

	t.Run("character not found", func(t *testing.T) {
		mockInvRepo := new(MockInventoryRepository)
		mockCharRepo := new(MockCharacterRepository)
		service := NewInventoryService(mockInvRepo, mockCharRepo)

		mockCharRepo.On("GetCharacterByID", "char-123").Return(nil, nil)

		err := service.AddItemToCharacter("char-123", "item-456", 1)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "character not found")
	})

	t.Run("item not found", func(t *testing.T) {
		mockInvRepo := new(MockInventoryRepository)
		mockCharRepo := new(MockCharacterRepository)
		service := NewInventoryService(mockInvRepo, mockCharRepo)

		character := &models.Character{ID: "char-123", Name: "Test Character"}
		mockCharRepo.On("GetCharacterByID", "char-123").Return(character, nil)
		mockInvRepo.On("GetItem", "item-456").Return(nil, nil)

		err := service.AddItemToCharacter("char-123", "item-456", 1)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "item not found")
	})
}

func TestInventoryService_EquipItem(t *testing.T) {
	t.Run("equip weapon successfully", func(t *testing.T) {
		mockInvRepo := new(MockInventoryRepository)
		mockCharRepo := new(MockCharacterRepository)
		service := NewInventoryService(mockInvRepo, mockCharRepo)

		characterID := "char-123"
		weaponID := "weapon-123"

		inventory := []*models.InventoryItem{
			{
				ItemID: weaponID,
				Item: &models.Item{
					ID:   weaponID,
					Type: models.ItemTypeWeapon,
					Properties: models.ItemProperties{
						"two_handed": false,
					},
				},
			},
		}

		mockInvRepo.On("GetCharacterInventory", characterID).Return(inventory, nil)
		mockInvRepo.On("EquipItem", characterID, weaponID, true).Return(nil)

		err := service.EquipItem(characterID, weaponID)
		assert.NoError(t, err)
		mockInvRepo.AssertExpectations(t)
	})

	t.Run("equip armor unequips previous armor", func(t *testing.T) {
		mockInvRepo := new(MockInventoryRepository)
		mockCharRepo := new(MockCharacterRepository)
		service := NewInventoryService(mockInvRepo, mockCharRepo)

		characterID := "char-123"
		newArmorID := "armor-new"
		oldArmorID := "armor-old"

		inventory := []*models.InventoryItem{
			{
				ItemID:   oldArmorID,
				Equipped: true,
				Item: &models.Item{
					ID:   oldArmorID,
					Type: models.ItemTypeArmor,
				},
			},
			{
				ItemID: newArmorID,
				Item: &models.Item{
					ID:   newArmorID,
					Type: models.ItemTypeArmor,
				},
			},
		}

		mockInvRepo.On("GetCharacterInventory", characterID).Return(inventory, nil)
		mockInvRepo.On("EquipItem", characterID, oldArmorID, false).Return(nil)
		mockInvRepo.On("EquipItem", characterID, newArmorID, true).Return(nil)

		err := service.EquipItem(characterID, newArmorID)
		assert.NoError(t, err)
		mockInvRepo.AssertExpectations(t)
	})

	t.Run("cannot equip two-handed weapon with shield", func(t *testing.T) {
		mockInvRepo := new(MockInventoryRepository)
		mockCharRepo := new(MockCharacterRepository)
		service := NewInventoryService(mockInvRepo, mockCharRepo)

		characterID := "char-123"
		twoHandedID := "2h-weapon"
		shieldID := "shield"

		inventory := []*models.InventoryItem{
			{
				ItemID:   shieldID,
				Equipped: true,
				Item: &models.Item{
					ID:         shieldID,
					Type:       models.ItemTypeWeapon,
					Properties: models.ItemProperties{"two_handed": false},
				},
			},
			{
				ItemID: twoHandedID,
				Item: &models.Item{
					ID:         twoHandedID,
					Type:       models.ItemTypeWeapon,
					Properties: models.ItemProperties{"two_handed": true},
				},
			},
		}

		mockInvRepo.On("GetCharacterInventory", characterID).Return(inventory, nil)

		err := service.EquipItem(characterID, twoHandedID)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "not enough hands")
	})

	t.Run("item not in inventory", func(t *testing.T) {
		mockInvRepo := new(MockInventoryRepository)
		mockCharRepo := new(MockCharacterRepository)
		service := NewInventoryService(mockInvRepo, mockCharRepo)

		mockInvRepo.On("GetCharacterInventory", "char-123").Return([]*models.InventoryItem{}, nil)

		err := service.EquipItem("char-123", "item-456")
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "item not found in inventory")
	})
}

func TestInventoryService_AttuneToItem(t *testing.T) {
	t.Run("successful attunement", func(t *testing.T) {
		mockInvRepo := new(MockInventoryRepository)
		mockCharRepo := new(MockCharacterRepository)
		service := NewInventoryService(mockInvRepo, mockCharRepo)

		characterID := "char-123"
		itemID := "magic-item"

		inventory := []*models.InventoryItem{
			{
				ItemID:  itemID,
				Attuned: false,
				Item: &models.Item{
					ID:                 itemID,
					RequiresAttunement: true,
				},
			},
		}

		mockInvRepo.On("GetCharacterInventory", characterID).Return(inventory, nil)
		mockInvRepo.On("AttuneItem", characterID, itemID).Return(nil)

		err := service.AttuneToItem(characterID, itemID)
		assert.NoError(t, err)
		mockInvRepo.AssertExpectations(t)
	})

	t.Run("item does not require attunement", func(t *testing.T) {
		mockInvRepo := new(MockInventoryRepository)
		mockCharRepo := new(MockCharacterRepository)
		service := NewInventoryService(mockInvRepo, mockCharRepo)

		characterID := "char-123"
		itemID := "regular-item"

		inventory := []*models.InventoryItem{
			{
				ItemID: itemID,
				Item: &models.Item{
					ID:                 itemID,
					RequiresAttunement: false,
				},
			},
		}

		mockInvRepo.On("GetCharacterInventory", characterID).Return(inventory, nil)

		err := service.AttuneToItem(characterID, itemID)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "item does not require attunement")
	})

	t.Run("already attuned", func(t *testing.T) {
		mockInvRepo := new(MockInventoryRepository)
		mockCharRepo := new(MockCharacterRepository)
		service := NewInventoryService(mockInvRepo, mockCharRepo)

		characterID := "char-123"
		itemID := "magic-item"

		inventory := []*models.InventoryItem{
			{
				ItemID:  itemID,
				Attuned: true,
				Item: &models.Item{
					ID:                 itemID,
					RequiresAttunement: true,
				},
			},
		}

		mockInvRepo.On("GetCharacterInventory", characterID).Return(inventory, nil)

		err := service.AttuneToItem(characterID, itemID)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "already attuned")
	})
}

func TestInventoryService_PurchaseItem(t *testing.T) {
	t.Run("successful purchase", func(t *testing.T) {
		mockInvRepo := new(MockInventoryRepository)
		mockCharRepo := new(MockCharacterRepository)
		service := NewInventoryService(mockInvRepo, mockCharRepo)

		characterID := "char-123"
		itemID := "item-456"
		quantity := 2

		item := &models.Item{
			ID:    itemID,
			Name:  "Healing Potion",
			Value: 50, // 50 copper
		}

		currency := &models.Currency{
			CharacterID: characterID,
			Gold:        5, // 500 copper
		}

		mockInvRepo.On("GetItem", itemID).Return(item, nil)
		mockInvRepo.On("GetCharacterCurrency", characterID).Return(currency, nil)
		mockInvRepo.On("UpdateCharacterCurrency", mock.MatchedBy(func(c *models.Currency) bool {
			return c.Gold == 4 // Should have 4 gold left (500 - 100 = 400 copper = 4 gold)
		})).Return(nil)
		mockInvRepo.On("AddItemToInventory", characterID, itemID, quantity).Return(nil)

		err := service.PurchaseItem(characterID, itemID, quantity)
		assert.NoError(t, err)
		mockInvRepo.AssertExpectations(t)
	})

	t.Run("insufficient funds", func(t *testing.T) {
		mockInvRepo := new(MockInventoryRepository)
		mockCharRepo := new(MockCharacterRepository)
		service := NewInventoryService(mockInvRepo, mockCharRepo)

		characterID := "char-123"
		itemID := "expensive-item"

		item := &models.Item{
			ID:    itemID,
			Value: 1000, // 1000 copper
		}

		currency := &models.Currency{
			CharacterID: characterID,
			Gold:        5, // Only 500 copper
		}

		mockInvRepo.On("GetItem", itemID).Return(item, nil)
		mockInvRepo.On("GetCharacterCurrency", characterID).Return(currency, nil)

		err := service.PurchaseItem(characterID, itemID, 1)
		assert.Error(t, err)
		assert.Contains(t, err.Error(), "insufficient funds")
	})
}

func TestInventoryService_SellItem(t *testing.T) {
	t.Run("successful sale", func(t *testing.T) {
		mockInvRepo := new(MockInventoryRepository)
		mockCharRepo := new(MockCharacterRepository)
		service := NewInventoryService(mockInvRepo, mockCharRepo)

		characterID := "char-123"
		itemID := "item-456"
		quantity := 1

		item := &models.Item{
			ID:    itemID,
			Name:  "Sword",
			Value: 100, // 100 copper, sells for 50
		}

		currency := &models.Currency{
			CharacterID: characterID,
			Gold:        1, // 100 copper
		}

		mockInvRepo.On("GetItem", itemID).Return(item, nil)
		mockInvRepo.On("RemoveItemFromInventory", characterID, itemID, quantity).Return(nil)
		mockInvRepo.On("GetCharacterCurrency", characterID).Return(currency, nil)
		mockInvRepo.On("UpdateCharacterCurrency", mock.MatchedBy(func(c *models.Currency) bool {
			return c.TotalInCopper() == 150 // 100 + 50 from sale
		})).Return(nil)

		err := service.SellItem(characterID, itemID, quantity)
		assert.NoError(t, err)
		mockInvRepo.AssertExpectations(t)
	})
}

func TestCurrency_Methods(t *testing.T) {
	t.Run("TotalInCopper", func(t *testing.T) {
		currency := &models.Currency{
			Copper:   5,
			Silver:   3,
			Electrum: 2,
			Gold:     1,
			Platinum: 1,
		}

		total := currency.TotalInCopper()
		assert.Equal(t, 1235, total) // 5 + 30 + 100 + 100 + 1000
	})

	t.Run("CanAfford", func(t *testing.T) {
		currency := &models.Currency{
			Gold: 5, // 500 copper
		}

		assert.True(t, currency.CanAfford(400))
		assert.True(t, currency.CanAfford(500))
		assert.False(t, currency.CanAfford(501))
	})

	t.Run("Subtract", func(t *testing.T) {
		currency := &models.Currency{
			Platinum: 1,
			Gold:     25,
			Silver:   8,
			Copper:   7,
		}

		// Subtract 1337 copper
		success := currency.Subtract(1337)
		assert.True(t, success)
		
		// Should have 2250 copper left (3587 - 1337)
		assert.Equal(t, 2, currency.Platinum)
		assert.Equal(t, 2, currency.Gold)
		assert.Equal(t, 1, currency.Electrum)
		assert.Equal(t, 0, currency.Silver)
		assert.Equal(t, 0, currency.Copper)
	})
}